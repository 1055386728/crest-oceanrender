// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel AnimWavesGerstnerBatchCompute

//// START SHARED HEADERS
// Samplers and data associated with a LOD.
// _LD_Params: float4(world texel size, texture resolution, shape weight multiplier, 1 / texture resolution)
#define LOD_DATA(LODNUM) \
	uniform sampler2D _LD_Sampler_AnimatedWaves_##LODNUM; \
	uniform sampler2D _LD_Sampler_SeaFloorDepth_##LODNUM; \
	uniform sampler2D _LD_Sampler_Foam_##LODNUM; \
	uniform sampler2D _LD_Sampler_Flow_##LODNUM; \
	uniform sampler2D _LD_Sampler_DynamicWaves_##LODNUM; \
	uniform sampler2D _LD_Sampler_Shadow_##LODNUM; \
	uniform float4 _LD_Params_##LODNUM; \
	uniform float3 _LD_Pos_Scale_##LODNUM;

// Create two sets of LOD data, which have overloaded meaning depending on use:
// * the ocean surface geometry always lerps from a more detailed LOD (0) to a less detailed LOD (1)
// * simulations (persistent lod data) read last frame's data from slot 0, and any current frame data from slot 1
// * any other use that does not fall into the previous categories can use either slot and generally use slot 0
LOD_DATA( 0 )
LOD_DATA( 1 )

#define CREST_OCEAN_DEPTH_BASELINE 1000.

// Geometry data
// x: Grid size of lod data - size of lod data texel in world space.
// y: Grid size of geometry - distance between verts in mesh.
// zw: normalScrollSpeed0, normalScrollSpeed1
uniform float4 _GeomData;
uniform float3 _OceanCenterPosWorld;

// Conversions for world space from/to UV space
float2 LD_WorldToUV(in float2 i_samplePos, in float2 i_centerPos, in float i_res, in float i_texelSize)
{
	return (i_samplePos - i_centerPos) / (i_texelSize * i_res) + 0.5;
}
float2 LD_0_WorldToUV(in float2 i_samplePos) { return LD_WorldToUV(i_samplePos, _LD_Pos_Scale_0.xy, _LD_Params_0.y, _LD_Params_0.x); }
float2 LD_1_WorldToUV(in float2 i_samplePos) { return LD_WorldToUV(i_samplePos, _LD_Pos_Scale_1.xy, _LD_Params_1.y, _LD_Params_1.x); }

float2 LD_UVToWorld(in float2 i_uv, in float2 i_centerPos, in float i_res, in float i_texelSize)
{
	return i_texelSize * i_res * (i_uv - 0.5) + i_centerPos;
}
float2 LD_0_UVToWorld(in float2 i_uv) { return LD_UVToWorld(i_uv, _LD_Pos_Scale_0.xy, _LD_Params_0.y, _LD_Params_0.x); }
float2 LD_1_UVToWorld(in float2 i_uv) { return LD_UVToWorld(i_uv, _LD_Pos_Scale_1.xy, _LD_Params_1.y, _LD_Params_1.x); }

// Conversions for world space from/to id space
float2 LD_WorldToID(in float2 i_samplePos, in float2 i_centerPos, in float i_res, in float i_texelSize)
{
	return ((i_samplePos - i_centerPos) / i_texelSize) + (0.5 * i_res);
}
float2 LD_0_WorldToID(in float2 i_samplePos) { return LD_WorldToID(i_samplePos, _LD_Pos_Scale_0.xy, _LD_Params_0.y, _LD_Params_0.x); }
float2 LD_1_WorldToID(in float2 i_samplePos) { return LD_WorldToID(i_samplePos, _LD_Pos_Scale_1.xy, _LD_Params_1.y, _LD_Params_1.x); }

float2 LD_IDToWorld(in float2 i_id, in float2 i_centerPos, in float i_res, in float i_texelSize)
{
	return i_texelSize * (i_id - (i_res * 0.5)) + i_centerPos;
}
float2 LD_0_IDToWorld(in float2 i_id) { return LD_IDToWorld(i_id, _LD_Pos_Scale_0.xy, _LD_Params_0.y, _LD_Params_0.x); }
float2 LD_1_IDToWorld(in float2 i_id) { return LD_IDToWorld(i_id, _LD_Pos_Scale_1.xy, _LD_Params_1.y, _LD_Params_1.x); }

// TODO(Tom): make sure this actually works
float4 IDtoUV(in float2 i_id)
{
	return float4(float2(i_id) / float2(256, 256) + 0.5 / float2(256, 256), 0, 0);
}

// END SHARED HEADERS TODO(Tom) SORT

// IMPORTANT - this mirrors the constant with the same name in ShapeGerstnerBatched.cs, both must be updated together!
#define BATCH_SIZE 32

#define PI 3.141593

float _NumInBatch;
half _AttenuationInShallows;
uint _NumWaveVecs;

half4 _TwoPiOverWavelengths[BATCH_SIZE / 4];
half4 _Amplitudes[BATCH_SIZE / 4];
half4 _WaveDirX[BATCH_SIZE / 4];
half4 _WaveDirZ[BATCH_SIZE / 4];
half4 _Phases[BATCH_SIZE / 4];
half4 _ChopAmps[BATCH_SIZE / 4];

RWTexture2D<float4> Result;

[numthreads(8,8,1)]
void AnimWavesGerstnerBatchCompute (uint3 id : SV_DispatchThreadID)
{
    const half4 oneMinusAttenuation = (half4)1.0 - (half4)_AttenuationInShallows;

    float4 uv = IDtoUV(id.xy);
    float2 worldXZ = LD_0_IDToWorld(id.xy);

    // sample ocean depth (this render target should 1:1 match depth texture, so UVs are trivial)
    const half depth = CREST_OCEAN_DEPTH_BASELINE - tex2Dlod(_LD_Sampler_SeaFloorDepth_0, uv).x;
    half3 result = (half3)0.0;

    // gerstner computation is vectorized - processes 4 wave components at once
    for (uint vi = 0; vi < _NumWaveVecs; vi++)
    {
        // attenuate waves based on ocean depth. if depth is greater than 0.5*wavelength, water is considered Deep and wave is
        // unaffected. if depth is less than this, wave velocity decreases. waves will then bunch up and grow in amplitude and
        // eventually break. i model "Deep" water, but then simply ramp down waves in non-deep water with a linear multiplier.
        // http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html
        // http://hyperphysics.phy-astr.gsu.edu/hbase/watwav.html#c1
        //half depth_wt = saturate(depth / (0.5 * _MinWavelength)); // slightly different result - do per wavelength for now
        // The below is a few things collapsed together.
        half4 depth_wt = saturate(depth * _TwoPiOverWavelengths[vi] / PI);
        // keep some proportion of amplitude so that there is some waves remaining
        half4 wt = _AttenuationInShallows * depth_wt + oneMinusAttenuation;

        // direction
        half4 Dx = _WaveDirX[vi];
        half4 Dz = _WaveDirZ[vi];
        // wave number
        half4 k = _TwoPiOverWavelengths[vi];
        // spatial location
        half4 x = Dx * worldXZ.x + Dz * worldXZ.y;
        half4 angle = k * x + _Phases[vi];

        // dx and dz could be baked into _ChopAmps
        half4 disp = _ChopAmps[vi] * sin(angle);
        half4 resultx = disp * Dx;
        half4 resultz = disp * Dz;

        half4 resulty = _Amplitudes[vi] * cos(angle);

        // sum the vector results
        result.x += dot(resultx, wt);
        result.y += dot(resulty, wt);
        result.z += dot(resultz, wt);
    }

    Result[id.xy] += half4(result, 0);
}
